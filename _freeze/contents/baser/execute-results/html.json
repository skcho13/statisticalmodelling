{
  "hash": "224dae2bdbf44093a177af8ab8dbceb9",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Base R\ndate: last-modified\nauthor: Sungkyun Cho\nexecute:\n  warning: false\n  freeze: auto\n---\n\n90년대에 통계 분석을 위해 개발된 R 언어와 대비하여, 좀 더 직관적이고 효율적인 데이터 분석을 위해 새로운 문법이 R내의 패키지 형태로 구현되었는데 이 새로운 생태계 안의 패키지들의 모임이 **Tidyverse**라는 이름하에 발전하고 있음: [Tidyverse](https://www.tidyverse.org/)  \n이 패키지들은 design philosophy, grammar, data structures를 공유하며 유기적으로 작동됨.  \n\n기존 R의 문법과는 상당한 차이가 있어 단점도 지적되고 있고, 소위 base-R을 고수하는 사람들과 tidyverse를 기본으로 사용하는 사람들이 나뉘어 있다고 알려져 있음.  \n\n아마도 빠르게 발전하고 있는 tidyverse/tidymodel 생태계의 언어들이 기본으로 자리잡지 않을까 함.  \n본 강의에서는 주로 tidyverse의 언어로만 분석하고자 함.  \n\n\n## R의 데이터 구조와 변수 타입\n\n주로 **vector (벡터)**와 **data frame (데이터프레임)**을 다룸\n\n![](images/dataframe.png){width=400}  \nSource: R in Action by Rob Kabacoff\n\n\n\n**Data frame**의 예  \n\n- 각 column이 하나의 **variable** (변수)를 구성하고, 한가지 타입의 데이터로 이루어짐  \n- 각 Row가 하나의 **observation** (관측치)을 구성함.  \n- 이러한 형태를 갖춘 데이터를 tidy라고도 부르며, 이를 벗어난 형태의 경우 가공이 필요함.  \n  ex. \"m23\": male이고 23세임을 나타내는 표기도 있음\n\n::: {#748da927 .cell vscode='{\"languageId\":\"r\"}' execution_count=2}\n``` {.r .cell-code}\nlibrary(tidyverse)\n\ncps <- mosaicData::CPS85 # mosaicData package의 CPS85 데이터셋\nhead(cps) |> print() # print()는 생략할 것!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  wage educ race sex hispanic south married exper union age   sector\n1  9.0   10    W   M       NH    NS Married    27   Not  43    const\n2  5.5   12    W   M       NH    NS Married    20   Not  38    sales\n3  3.8   12    W   F       NH    NS  Single     4   Not  22    sales\n4 10.5   12    W   F       NH    NS Married    29   Not  47 clerical\n5 15.0   12    W   M       NH    NS Married    40 Union  58    const\n6  9.0   16    W   F       NH    NS Married    27   Not  49 clerical\n```\n:::\n:::\n\n\n::: {#38a2909c .cell vscode='{\"languageId\":\"r\"}' execution_count=3}\n``` {.r .cell-code}\ncps <- as_tibble(cps) # tibble vs. data.frame\nhead(cps) |> print()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 11\n   wage  educ race  sex   hispanic south married exper union   age sector  \n  <dbl> <int> <fct> <fct> <fct>    <fct> <fct>   <int> <fct> <int> <fct>   \n1   9      10 W     M     NH       NS    Married    27 Not      43 const   \n2   5.5    12 W     M     NH       NS    Married    20 Not      38 sales   \n3   3.8    12 W     F     NH       NS    Single      4 Not      22 sales   \n4  10.5    12 W     F     NH       NS    Married    29 Not      47 clerical\n5  15      12 W     M     NH       NS    Married    40 Union    58 const   \n6   9      16 W     F     NH       NS    Married    27 Not      49 clerical\n```\n:::\n:::\n\n\n::: {#5922c0b3 .cell vscode='{\"languageId\":\"r\"}' execution_count=4}\n``` {.r .cell-code}\n# Dataset의 설명\nhelp(CPS85, package=\"mosaicData\") # 또는\n?mosaicData::CPS85\n```\n:::\n\n\n## Vector\n한 가지 타입으로만 구성: 숫자 (numeric), 문자 (character), 논리형 (logical), factor, etc\n\n::: {#f4e7cdc4 .cell vscode='{\"languageId\":\"r\"}' execution_count=5}\n``` {.r .cell-code}\nvar <- c(1, 2, 5, 3, 6, -2, 4) # 변수에 assign: '=' 대신 '<-'\nnm <- c(\"one\", \"two\", \"three\")\ntf <- c(TRUE, TRUE, TRUE, FALSE, TRUE, FALSE)\n\n# 타입/클래스 확인\nclass(var)\n## [1] \"double\"\n\nclass(nm)\n## [1] \"character\"\n\nclass(tf)\n## [1] \"logical\"\n```\n:::\n\n\n### 원소의 추출 및 대체\n다음은 원소를 추출, 대체하는 R의 native한 방식임  \n수업에서는 뒤에서 다룰 tidyverse 문법을 주로 활용할 것임  \n\nVector의 경우\n\n::: {#b27ee9d8 .cell vscode='{\"languageId\":\"r\"}' execution_count=6}\n``` {.r .cell-code}\nvar\n## [1]  1  2  5  3  6 -2  4\n\nvar[3]\n## [1] 5\n\nvar[c(1, 3, 5)]\n## [1] 1 5 6\n\nvar[2:6] # \":\"\" slicing: c(2, 3, 4, 5, 6)\n## [1]  2  5  3  6 -2\n\nvar[c(1, 3:5)] # 혼합\n## [1] 1 5 3 6\n\nvar[-c(1, 3)] # \"-\"는 제외라는 의미\n## [1]  2  3  6 -2  4\n\nc(10, var, 100, 101) # 추가\n##  [1]  10   1   2   5   3   6  -2   4 100 101\n\nvar[2] <- 55 # 대체\n## var\n## [1]  1 55  5  3  6 -2  4\n\nvar[c(2, 5)] <- c(200, 500) # 대체\n## var\n## [1]   1 200   5   3 500  -2   4\n\n# numeric 벡터의 연산: recycling rule\n1:5 * 2\n## [1]  2  4  6  8 10\n\nc(1, 3, 5) - 5\n## [1] -4 -2  0\n\nc(2, 4, 6) / 2\n## [1] 1 2 3\n\nc(1, 3) * c(2, 4)\n## [1]  2 12\n\nc(1, 3) - c(2, 4)\n## [1] -1 -1\n```\n:::\n\n\n## **Factor**\nVector로서 명목변수(카테고리)를 다룸\n\n```r\npatientID <- c(1, 2, 1, 3)\ndiabetes <- c(\"Type1\", \"Type2\", \"Type1\", \"Type1\")\nstatus <- c(\"Poor\", \"Improved\", \"Excellent\", \"Poor\")\n\n# factor로 변환: 알파벳 순서로 levels의 순서가 정해짐\nfactor(patientID)\n## [1] 1 2 1 3\n## Levels: 1 2 3\n\nfactor(diabetes)\n## [1] Type1 Type2 Type1 Type1\n## Levels: Type1 Type2\n\nfactor(status, order = TRUE) # order를 표시\n## [1] Poor      Improved  Excellent Poor     \n## Levels: Excellent < Improved < Poor\n\n# 구체적으로 표시하는 것을 추천: 지정한 성분 순서대로 levels의 순서가 정해짐\nfactor(status, levels = c(\"Poor\", \"Improved\", \"Excellent\"),\n                                         order = TRUE)\n## [1] Poor      Improved  Excellent Poor     \n## Levels: Poor < Improved < Excellent\n\n# order가 없을시\nfactor(status, levels = c(\"Poor\", \"Improved\", \"Excellent\"))\n## [1] Poor      Improved  Excellent Poor     \n## Levels: Poor Improved Excellent\n\n# 대표적으로 성별을 코딩할 때: 숫자대신 레이블로 표시\nsex <- c(1, 2, 1, 1, 1, 2, 2, 1)\nfactor(sex, levels = c(1, 2), labels = c(\"Male\", \"Female\"))\n## [1] Male   Female Male   Male   Male   Female Female Male  \n## Levels: Male Female\n\nsex_fct <- factor(sex, levels = c(1, 2), labels = c(\"Male\", \"Female\"))\n\nlevels(sex) # 레벨 확인\n## NULL\nlevels(sex_fct) # 레벨 확인\n## [1] \"Male\"   \"Female\"\n\nsex\n## [1] 1 2 1 1 1 2 2 1\nsex_fct\n## [1] Male   Female Male   Male   Male   Female Female Male  \n## Levels: Male Female\n```\n\n## Data Frame\n\n### 데이터 프레임의 구성\n\n```r\n# 벡터들로부터 데이터 프레임 구성\npatientID <- c(1, 2, 3, 4)\nage <- c(25, 34, 28, 52)\ndiabetes <- c(\"Type1\", \"Type2\", \"Type1\", \"Type1\")\nstatus <- c(\"Poor\", \"Improved\", \"Excellent\", \"Poor\")\n\npatientdata <- data.frame(patientID, age, diabetes, status)\n\npatientdata\n##   patientID age diabetes    status\n## 1         1  25    Type1      Poor\n## 2         2  34    Type2  Improved\n## 3         3  28    Type1 Excellent\n## 4         4  52    Type1      Poor\n\nmidterm <- data.frame(english = c(90, 80, 60, 70),\n                      math = c(50, 60, 100, 20),\n                      class = c(1, 1, 2, 2))\nmidterm\n##   english math class\n## 1      90   50     1\n## 2      80   60     1\n## 3      60  100     2\n## 4      70   20     2\n```\n\n### 원소의 추출 및 대체\n\n```r\n# 원소의 추출\npatientdata[1:2] # 변수의 열을 지정\n##   patientID age\n## 1         1  25\n## 2         2  34\n## 3         3  28\n## 4         4  52\n\npatientdata[c(\"diabetes\", \"status\")] # 열 이름을 지정\n##   diabetes    status\n## 1    Type1      Poor\n## 2    Type2  Improved\n## 3    Type1 Excellent\n## 4    Type1      Poor\n\npatientdata[c(1, 3), c(\"age\", \"status\")] # 행과 열을 모두 지정\n##   age    status\n## 1  25      Poor\n## 3  28 Excellent\n\npatientdata[c(1, 3), c(2, 4)]\n##   age    status\n## 1  25      Poor\n## 3  28 Excellent\n\npatientdata[, 1:2] # patientdata[1:2]과 동일, 빈칸은 모든 행을 의미\n##   patientID age\n## 1         1  25\n## 2         2  34\n## 3         3  28\n## 4         4  52\n\npatientdata[1:2, ] # 빈칸은 모든 열을 의미\n##   patientID age diabetes   status\n## 1         1  25    Type1     Poor\n## 2         2  34    Type2 Improved\n\npatientdata[-1] # 열 제외\n##   age diabetes    status\n## 1  25    Type1      Poor\n## 2  34    Type2  Improved\n## 3  28    Type1 Excellent\n## 4  52    Type1      Poor\n\npatientdata[-c(1, 3)] # 열 제외\n##   age    status\n## 1  25      Poor\n## 2  34  Improved\n## 3  28 Excellent\n## 4  52      Poor\n\npatientdata[-c(1:2), 2:4] # 행 제외 & 열 선택\n##   age diabetes    status\n## 3  28    Type1 Excellent\n## 4  52    Type1      Poor\n\n\n# 변수/열의 성분을 벡터로 추출: $ 또는 [[ ]]을 이용\npatientdata$age # $를 이용\n## [1] 25 34 28 52\n\nclass(patientdata$age) # numeric vector임을 확인\n## [1] \"numeric\"\n\npatientdata[[\"age\"]] # patientdata$age과 동일, [[ ]] doule bracket을 이용해 벡터로 추출\n## [1] 25 34 28 52\n\npatientdata[[2]] # 열의 위치를 이용해도 동일한 추출\n## [1] 25 34 28 52\n\npatientdata[\"age\"] # [ ] single bracket은 열을 선택하는 것으로 데이터 프레임으로 추출\n##   age\n## 1  25\n## 2  34\n## 3  28\n## 4  52\n\npatientdata[2] # 2번째 열을 추출; patientdata[\"age\"]과 동일\n##   age\n## 1  25\n## 2  34\n## 3  28\n## 4  52\n```\n\n### 데이터의 추가 및 대체\n\n```r\n# 데이터 추가\npatientdata$gender <- c(1, 1, 2, 2) \n\npatientdata\n##   patientID age diabetes    status gender\n## 1         1  25    Type1      Poor      1\n## 2         2  34    Type2  Improved      1\n## 3         3  28    Type1 Excellent      2\n## 4         4  52    Type1      Poor      2\n\n# 데이터 대체\npatientdata[c(1,3), \"age\"] # 혼동: 원칙적으로 데이터프레임으로 추출되어야하나 벡터로 추출됨\n## [1] 25 28\n\npatientdata[c(1,3), \"age\"] <- c(88, 99)\npatientdata\n##   patientID age diabetes    status gender\n## 1         1  88    Type1      Poor      1\n## 2         2  34    Type2  Improved      1\n## 3         3  99    Type1 Excellent      2\n## 4         4  52    Type1      Poor      2\n\n# 참고\nrow.names(patientdata) # 데이터 프레임의 행 이름\n## [1] \"1\" \"2\" \"3\" \"4\"\n\nrow.names(patientdata) <- c(\"a\", \"b\", \"c\", \"d\")\npatientdata\n##   patientID age diabetes    status gender\n## a         1  88    Type1      Poor      1\n## b         2  34    Type2  Improved      1\n## c         3  99    Type1 Excellent      2\n## d         4  52    Type1      Poor      2\n```\n\n## Tibble\n기존 data.frame의 단점을 보안한 tidyverse에서 기본이 되는 데이터 형식\n\n### Data frame vs. tibble\nPrinting의 차이\n\n```r\ncps <- mosaicData::CPS85 # data.frame\ncps\n#   wage educ race sex hispanic south married exper union age   sector\n# 1  9.0   10    W   M       NH    NS Married    27   Not  43    const\n# 2  5.5   12    W   M       NH    NS Married    20   Not  38    sales\n# 3  3.8   12    W   F       NH    NS  Single     4   Not  22    sales\n# 4 10.5   12    W   F       NH    NS Married    29   Not  47 clerical\n# 5 15.0   12    W   M       NH    NS Married    40 Union  58    const\n# 6  9.0   16    W   F       NH    NS Married    27   Not  49 clerical\n...\n\ncps_tibble <- as_tibble(cps)\ncps_tibble\n# # A tibble: 534 × 11\n#    wage  educ race  sex   hispanic south married exper union   age sector  \n#   <dbl> <int> <fct> <fct> <fct>    <fct> <fct>   <int> <fct> <int> <fct>   \n# 1   9      10 W     M     NH       NS    Married    27 Not      43 const   \n# 2   5.5    12 W     M     NH       NS    Married    20 Not      38 sales   \n# 3   3.8    12 W     F     NH       NS    Single      4 Not      22 sales   \n# 4  10.5    12 W     F     NH       NS    Married    29 Not      47 clerical\n# 5  15      12 W     M     NH       NS    Married    40 Union    58 const   \n# 6   9      16 W     F     NH       NS    Married    27 Not      49 clerical\n# # … with 528 more rows\n```\n\n그 외의 차이는 [R for Data Science/10.3 Tibbles vs. data.frame](https://r4ds.had.co.nz/tibbles.html)을 참고\n\n",
    "supporting": [
      "baser_files"
    ],
    "filters": [],
    "includes": {}
  }
}